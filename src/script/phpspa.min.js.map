{"version":3,"file":"phpspa.min.js","sources":["../utils/baseConverter.ts","../core/RuntimeManager.ts","../../node_modules/.pnpm/morphdom@2.7.7/node_modules/morphdom/dist/morphdom-esm.js","../core/AppManager.ts","../index.ts"],"sourcesContent":["/**\r\n * UTF-8 safe base64 encoding function\r\n * Handles Unicode characters that btoa cannot process\r\n */\r\nexport function utf8ToBase64(str: string): string {\r\n   try {\r\n      // First try the native btoa for performance\r\n      return btoa(str);\r\n   } catch (e) {\r\n      // If btoa fails (due to non-Latin1 characters), use UTF-8 safe encoding\r\n      try {\r\n         // Modern replacement for unescape(encodeURIComponent(str))\r\n         const utf8Bytes = new TextEncoder().encode(str);\r\n         const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');\r\n         return btoa(binaryString);\r\n      } catch (fallbackError) {\r\n         // Final fallback: encode each character individually\r\n         return btoa(\r\n            str.split('').map(function (c) {\r\n               return String.fromCharCode(c.charCodeAt(0) & 0xff);\r\n            }).join('')\r\n         );\r\n      }\r\n   }\r\n}\r\n\r\n/**\r\n * UTF-8 safe base64 decoding function\r\n * Handles Unicode characters that atob cannot process\r\n */\r\nexport function base64ToUtf8(str: string): string {\r\n   try {\r\n      // Try modern UTF-8 safe decoding first\r\n      const binaryString = atob(str);\r\n      const bytes = new Uint8Array(binaryString.length);\r\n      for (let i = 0; i < binaryString.length; i++) {\r\n         bytes[i] = binaryString.charCodeAt(i);\r\n      }\r\n      return new TextDecoder().decode(bytes);\r\n   } catch (e) {\r\n      // Fallback to regular atob\r\n      return atob(str);\r\n   }\r\n}\r\n","import { CurrentRoutesObject, EffectType, EventObject, EventPayload } from \"../types/RuntimeInterfaces\";\r\nimport { StateObject } from \"../types/StateObjectTypes\";\r\nimport { utf8ToBase64 } from \"../utils/baseConverter\";\r\n\r\n\r\n/**\r\n * Runtime Manager for PhpSPA\r\n *\r\n * Handles script execution, style injection, event management, and browser history\r\n * for the PhpSPA framework. Uses an obscure class name to avoid conflicts.\r\n */\r\nexport default class RuntimeManager {\r\n   /**\r\n    * Tracks executed scripts to prevent duplicates\r\n    */\r\n   private static executedScripts: Set<string> = new Set();\r\n\r\n   /**\r\n    * Tracks executed styles to prevent duplicates\r\n    */\r\n   private static executedStyles: Set<string> = new Set();\r\n\r\n   /**\r\n    * A static cache object that stores processed script content to avoid redundant processing.\r\n    * Used to improve performance by caching scripts that have already been processed or compiled.\r\n    */\r\n   private static ScriptsCachedContent: Record<string, string> = {};\r\n\r\n   /**\r\n    * This contains all routes for the current page\r\n    */\r\n   public static currentRoutes: CurrentRoutesObject = {};\r\n\r\n   public static events: EventObject = {\r\n      beforeload: [],\r\n      load: [],\r\n   };\r\n\r\n   private static effects: Set<EffectType> = new Set();\r\n\r\n   /**\r\n    * Registers a side effect to be executed when state changes\r\n    * similar to React's useEffect but using state keys strings as dependencies\r\n    *\r\n    * @param {Function} callback - The effect callback\r\n    * @param {Array<string>} dependencies - Array of state keys to listen for\r\n    */\r\n   public static registerEffect(callback: () => Function|undefined, dependencies: string[]|null = null): void {\r\n      // --- Run immediately (mount) ---\r\n      const cleanup = callback();\r\n\r\n      const effect: EffectType = {\r\n         callback,\r\n         dependencies,\r\n         cleanup: typeof cleanup === 'function' ? cleanup : null\r\n      };\r\n\r\n      RuntimeManager.effects.add(effect);\r\n   }\r\n\r\n   /**\r\n    * Triggers effects that depend on the specific state key\r\n    *\r\n    * @param key - The state key that changed\r\n    * @param value - The new value (optional)\r\n    */\r\n   public static triggerEffects(key: string, value: any): void {\r\n      RuntimeManager.effects.forEach(effect => {\r\n         if (effect.dependencies === null || effect.dependencies.includes(key)) {\r\n            // --- Run cleanup if exists ---\r\n            if (effect.cleanup) effect.cleanup();\r\n\r\n            // --- Re-run callback ---\r\n            const cleanup = effect.callback();\r\n            effect.cleanup = typeof cleanup === 'function' ? cleanup : null;\r\n         }\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Clears all registered effects and runs their cleanup functions\r\n    */\r\n   public static clearEffects(): void {\r\n      RuntimeManager.effects.forEach(effect => {\r\n         if (effect.cleanup) effect.cleanup();\r\n      });\r\n      RuntimeManager.effects.clear();\r\n   }\r\n\r\n   public static runAll(): void {\r\n      for (const targetID in RuntimeManager.currentRoutes) {\r\n         const element = document.getElementById(targetID);\r\n\r\n         if (element) {\r\n            this.runInlineScripts(element);\r\n            this.runPhpSpaScripts(element);\r\n            this.runInlineStyles(element);\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Processes and executes inline scripts within a container\r\n    * Creates isolated scopes using IIFE to prevent variable conflicts\r\n    */\r\n   private static runInlineScripts(container: HTMLElement) {\r\n      const scripts = container.querySelectorAll(\"script\");\r\n      const nonce = document.documentElement.getAttribute('x-phpspa');\r\n\r\n      scripts.forEach((script: HTMLScriptElement) => {\r\n         // --- Use base64 encoded content as unique identifier ---\r\n         const contentHash = utf8ToBase64(script.textContent.trim());\r\n\r\n         // --- Skip if this script has already been executed ---\r\n         if (!this.executedScripts.has(contentHash) && script.textContent.trim() !== \"\") {\r\n            this.executedScripts.add(contentHash);\r\n\r\n            // --- Create new script element ---\r\n            const newScript = document.createElement(\"script\");\r\n\r\n            newScript.nonce = nonce ?? undefined;\r\n\r\n            // --- Copy all attributes except the data-type identifier ---\r\n            for (const attribute of Array.from(script.attributes)) {\r\n               newScript.setAttribute(attribute.name, attribute.value);\r\n            }\r\n\r\n            // --- Check if script should run in async context ---\r\n            const isAsync = script.hasAttribute(\"async\");\r\n\r\n            // --- Wrap in IIFE to create isolated scope ---\r\n            if (isAsync) {\r\n               newScript.textContent = `(async function() {\\n${script.textContent}\\n})();`;\r\n            } else {\r\n               newScript.textContent = `(function() {\\n${script.textContent}\\n})();`;\r\n            }\r\n\r\n            // --- Execute and immediately remove from DOM ---\r\n            document.head.appendChild(newScript).remove();\r\n         }\r\n      });\r\n   }\r\n\r\n\r\n   static runPhpSpaScripts(container: HTMLElement) {\r\n      const scripts = container.querySelectorAll(\"phpspa-script, script[data-type=\\\"phpspa/script\\\"]\") as NodeListOf<HTMLScriptElement>;\r\n\r\n      scripts.forEach(async (script: HTMLScriptElement): Promise<void> => {\r\n         const scriptUrl = script.getAttribute('src') ?? '';\r\n         const scriptType = script.getAttribute('type') ?? '';\r\n         const nonce = document.documentElement.getAttribute('x-phpspa');\r\n\r\n         // --- Skip if this script has already been executed ---\r\n         if (!this.executedScripts.has(scriptUrl)) {\r\n            this.executedScripts.add(scriptUrl);\r\n\r\n            // --- Check cache first ---\r\n            if (this.ScriptsCachedContent[scriptUrl]) {\r\n               const newScript = document.createElement(\"script\");\r\n               newScript.textContent = this.ScriptsCachedContent[scriptUrl];\r\n               newScript.nonce = nonce ?? undefined;\r\n               newScript.type = scriptType;\r\n\r\n               // --- Execute and immediately remove from DOM ---\r\n               document.head.appendChild(newScript).remove();\r\n               return;\r\n            }\r\n\r\n            const response = await fetch(scriptUrl, {\r\n               headers: {\r\n                  \"X-Requested-With\": \"PHPSPA_REQUEST_SCRIPT\",\r\n               },\r\n            });\r\n\r\n            if (response.ok) {\r\n               const scriptContent = await response.text();\r\n\r\n               // --- Create new script element ---\r\n               const newScript = document.createElement(\"script\");\r\n               newScript.textContent = scriptContent;\r\n               newScript.nonce = nonce ?? undefined;\r\n               newScript.type = scriptType;\r\n\r\n               // --- Execute and immediately remove from DOM ---\r\n               document.head.appendChild(newScript).remove();\r\n\r\n               // --- Cache the fetched script content ---\r\n               this.ScriptsCachedContent[scriptUrl] = scriptContent;\r\n            } else {\r\n               console.error(`Failed to load script from ${scriptUrl}: ${response.statusText}`);\r\n            }\r\n         }\r\n      });\r\n   }\r\n\r\n\r\n   /**\r\n    * Clears all executed scripts from the runtime manager.\r\n    * This method removes all entries from the executedScripts collection,\r\n    * effectively resetting the tracking of previously executed scripts.\r\n    *\r\n    * @static\r\n    * @memberof RuntimeManager\r\n    */\r\n   public static clearExecutedScripts() {\r\n      RuntimeManager.executedScripts.clear();\r\n   }\r\n\r\n   /**\r\n    * Processes and injects inline styles within a container\r\n    * Prevents duplicate style injection by tracking content hashes\r\n    */\r\n   private static runInlineStyles(container: HTMLElement) {\r\n      const styles = container.querySelectorAll(\"style\");\r\n      const nonce = document.documentElement.getAttribute('x-phpspa');\r\n\r\n      styles.forEach((style: HTMLStyleElement) => {\r\n         // --- Use base64 encoded content as unique identifier ---\r\n         const contentHash = utf8ToBase64(style.textContent.trim());\r\n\r\n         // --- Skip if this style has already been injected ---\r\n         if (!this.executedStyles.has(contentHash) && style.textContent.trim() !== \"\") {\r\n            this.executedStyles.add(contentHash);\r\n\r\n            // --- Create new style element ---\r\n            const newStyle = document.createElement(\"style\");\r\n            newStyle.nonce = nonce ?? undefined;\r\n\r\n            // --- Copy all attributes except the data-type identifier ---\r\n            for (const attribute of Array.from(style.attributes)) {\r\n               newStyle.setAttribute(attribute.name, attribute.value);\r\n            }\r\n\r\n            // --- Copy style content and inject into head ---\r\n            newStyle.textContent = style.textContent;\r\n            document.head.appendChild(newStyle).remove();\r\n         }\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Emits a custom event to all registered listeners\r\n    * Used for lifecycle events like 'beforeload' and 'load'\r\n    *\r\n    * @param eventName - The name of the event to emit\r\n    * @param payload - The data to pass to event listeners\r\n    */\r\n   static emit(eventName: keyof EventObject, payload: EventPayload) {\r\n      const callbacks = this.events[eventName] || [];\r\n\r\n      // --- Execute all registered callbacks for this event ---\r\n      for (const callback of callbacks) {\r\n         if (typeof callback === \"function\") {\r\n            try {\r\n               callback(payload);\r\n            } catch (error) {\r\n               // --- Log callback errors but don't break the chain ---\r\n               console.error(`Error in ${eventName} event callback:`, error);\r\n            }\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Safely pushes a new state to browser history\r\n    * Wraps in try-catch to handle potential browser restrictions\r\n    */\r\n   public static pushState(data: StateObject, unused: string, url?: string | URL | null) {\r\n      try {\r\n         history.pushState(data, unused, url);\r\n      } catch (error) {\r\n         // --- Silently handle history API restrictions ---\r\n         console.warn(\"Failed to push history state:\", error instanceof Error ? error.message : error);\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Safely replaces current browser history state\r\n    * Wraps in try-catch to handle potential browser restrictions\r\n    */\r\n   public static replaceState(data: StateObject, unused: string, url?: string | URL | null) {\r\n      try {\r\n         history.replaceState(data, unused, url);\r\n      } catch (error) {\r\n         // --- Silently handle history API restrictions ---\r\n         console.warn(\"Failed to replace history state:\", error instanceof Error ? error.message : error);\r\n      }\r\n   }\r\n}\r\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                    // handle empty optgroups\n                    if (!curChild) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n    return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n  return function morphdom(fromNode, toNode, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof toNode === 'string') {\n      if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n        var toNodeHtml = toNode;\n        toNode = doc.createElement('html');\n        toNode.innerHTML = toNodeHtml;\n      } else {\n        toNode = toElement(toNode);\n      }\n    } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n      toNode = toNode.firstElementChild;\n    }\n\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n    var skipFromChildren = options.skipFromChildren || noop;\n    var addChild = options.addChild || function(parent, child){ return parent.appendChild(child); };\n    var childrenOnly = options.childrenOnly === true;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var fromNodesLookup = Object.create(null);\n    var keyedRemovalList = [];\n\n    function addKeyedRemoval(key) {\n      keyedRemovalList.push(key);\n    }\n\n    function walkDiscardedChildNodes(node, skipKeyedNodes) {\n      if (node.nodeType === ELEMENT_NODE) {\n        var curChild = node.firstChild;\n        while (curChild) {\n\n          var key = undefined;\n\n          if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n            // If we are skipping keyed nodes then we add the key\n            // to a list so that it can be handled at the very end.\n            addKeyedRemoval(key);\n          } else {\n            // Only report the node as discarded if it is not keyed. We do this because\n            // at the end we loop through all keyed elements that were unmatched\n            // and then discard them in one final pass.\n            onNodeDiscarded(curChild);\n            if (curChild.firstChild) {\n              walkDiscardedChildNodes(curChild, skipKeyedNodes);\n            }\n          }\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    /**\n    * Removes a DOM node out of the original DOM\n    *\n    * @param  {Node} node The node to remove\n    * @param  {Node} parentNode The nodes parent\n    * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n    * @return {undefined}\n    */\n    function removeNode(node, parentNode, skipKeyedNodes) {\n      if (onBeforeNodeDiscarded(node) === false) {\n        return;\n      }\n\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n\n      onNodeDiscarded(node);\n      walkDiscardedChildNodes(node, skipKeyedNodes);\n    }\n\n    // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n    // function indexTree(root) {\n    //     var treeWalker = document.createTreeWalker(\n    //         root,\n    //         NodeFilter.SHOW_ELEMENT);\n    //\n    //     var el;\n    //     while((el = treeWalker.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n    //\n    // function indexTree(node) {\n    //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    //     var el;\n    //     while((el = nodeIterator.nextNode())) {\n    //         var key = getNodeKey(el);\n    //         if (key) {\n    //             fromNodesLookup[key] = el;\n    //         }\n    //     }\n    // }\n\n    function indexTree(node) {\n      if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n        var curChild = node.firstChild;\n        while (curChild) {\n          var key = getNodeKey(curChild);\n          if (key) {\n            fromNodesLookup[key] = curChild;\n          }\n\n          // Walk recursively\n          indexTree(curChild);\n\n          curChild = curChild.nextSibling;\n        }\n      }\n    }\n\n    indexTree(fromNode);\n\n    function handleNodeAdded(el) {\n      onNodeAdded(el);\n\n      var curChild = el.firstChild;\n      while (curChild) {\n        var nextSibling = curChild.nextSibling;\n\n        var key = getNodeKey(curChild);\n        if (key) {\n          var unmatchedFromEl = fromNodesLookup[key];\n          // if we find a duplicate #id node in cache, replace `el` with cache value\n          // and morph it to the child node.\n          if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n            morphEl(unmatchedFromEl, curChild);\n          } else {\n            handleNodeAdded(curChild);\n          }\n        } else {\n          // recursively call for curChild and it's children to see if we find something in\n          // fromNodesLookup\n          handleNodeAdded(curChild);\n        }\n\n        curChild = nextSibling;\n      }\n    }\n\n    function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n      // We have processed all of the \"to nodes\". If curFromNodeChild is\n      // non-null then we still have some from nodes left over that need\n      // to be removed\n      while (curFromNodeChild) {\n        var fromNextSibling = curFromNodeChild.nextSibling;\n        if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n          // Since the node is keyed it might be matched up later so we defer\n          // the actual removal to later\n          addKeyedRemoval(curFromNodeKey);\n        } else {\n          // NOTE: we skip nested keyed nodes from being removed since there is\n          //       still a chance they will be matched up later\n          removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n        }\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n      var toElKey = getNodeKey(toEl);\n\n      if (toElKey) {\n        // If an element with an ID is being morphed then it will be in the final\n        // DOM so clear it out of the saved elements collection\n        delete fromNodesLookup[toElKey];\n      }\n\n      if (!childrenOnly) {\n        // optional\n        var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);\n        if (beforeUpdateResult === false) {\n          return;\n        } else if (beforeUpdateResult instanceof HTMLElement) {\n          fromEl = beforeUpdateResult;\n          // reindex the new fromEl in case it's not in the same\n          // tree as the original fromEl\n          // (Phoenix LiveView sometimes returns a cloned tree,\n          //  but keyed lookups would still point to the original tree)\n          indexTree(fromEl);\n        }\n\n        // update attributes on original DOM element first\n        morphAttrs(fromEl, toEl);\n        // optional\n        onElUpdated(fromEl);\n\n        if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n          return;\n        }\n      }\n\n      if (fromEl.nodeName !== 'TEXTAREA') {\n        morphChildren(fromEl, toEl);\n      } else {\n        specialElHandlers.TEXTAREA(fromEl, toEl);\n      }\n    }\n\n    function morphChildren(fromEl, toEl) {\n      var skipFrom = skipFromChildren(fromEl, toEl);\n      var curToNodeChild = toEl.firstChild;\n      var curFromNodeChild = fromEl.firstChild;\n      var curToNodeKey;\n      var curFromNodeKey;\n\n      var fromNextSibling;\n      var toNextSibling;\n      var matchingFromEl;\n\n      // walk the children\n      outer: while (curToNodeChild) {\n        toNextSibling = curToNodeChild.nextSibling;\n        curToNodeKey = getNodeKey(curToNodeChild);\n\n        // walk the fromNode children all the way through\n        while (!skipFrom && curFromNodeChild) {\n          fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          curFromNodeKey = getNodeKey(curFromNodeChild);\n\n          var curFromNodeType = curFromNodeChild.nodeType;\n\n          // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n          var isCompatible = undefined;\n\n          if (curFromNodeType === curToNodeChild.nodeType) {\n            if (curFromNodeType === ELEMENT_NODE) {\n              // Both nodes being compared are Element nodes\n\n              if (curToNodeKey) {\n                // The target node has a key so we want to match it up with the correct element\n                // in the original DOM tree\n                if (curToNodeKey !== curFromNodeKey) {\n                  // The current element in the original DOM tree does not have a matching key so\n                  // let's check our lookup to see if there is a matching element in the original\n                  // DOM tree\n                  if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                    if (fromNextSibling === matchingFromEl) {\n                      // Special case for single element removals. To avoid removing the original\n                      // DOM node out of the tree (since that can break CSS transitions, etc.),\n                      // we will instead discard the current node and wait until the next\n                      // iteration to properly match up the keyed target element with its matching\n                      // element in the original tree\n                      isCompatible = false;\n                    } else {\n                      // We found a matching keyed element somewhere in the original DOM tree.\n                      // Let's move the original DOM node into the current position and morph\n                      // it.\n\n                      // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                      // the `removeNode()` function for the node that is being discarded so that\n                      // all lifecycle hooks are correctly invoked\n                      fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                      // fromNextSibling = curFromNodeChild.nextSibling;\n\n                      if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                      } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                      }\n\n                      curFromNodeChild = matchingFromEl;\n                      curFromNodeKey = getNodeKey(curFromNodeChild);\n                    }\n                  } else {\n                    // The nodes are not compatible since the \"to\" node has a key and there\n                    // is no matching keyed node in the source tree\n                    isCompatible = false;\n                  }\n                }\n              } else if (curFromNodeKey) {\n                // The original has a key\n                isCompatible = false;\n              }\n\n              isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n              if (isCompatible) {\n                // We found compatible DOM elements so transform\n                // the current \"from\" node to match the current\n                // target DOM node.\n                // MORPH\n                morphEl(curFromNodeChild, curToNodeChild);\n              }\n\n            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n              // Both nodes being compared are Text or Comment nodes\n              isCompatible = true;\n              // Simply update nodeValue on the original node to\n              // change the text value\n              if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n              }\n\n            }\n          }\n\n          if (isCompatible) {\n            // Advance both the \"to\" child and the \"from\" child since we found a match\n            // Nothing else to do as we already recursively called morphChildren above\n            curToNodeChild = toNextSibling;\n            curFromNodeChild = fromNextSibling;\n            continue outer;\n          }\n\n          // No compatible match so remove the old node from the DOM and continue trying to find a\n          // match in the original DOM. However, we only do this if the from node is not keyed\n          // since it is possible that a keyed node might match up with a node somewhere else in the\n          // target tree and we don't want to discard it just yet since it still might find a\n          // home in the final DOM tree. After everything is done we will remove any keyed nodes\n          // that didn't find a home\n          if (curFromNodeKey) {\n            // Since the node is keyed it might be matched up later so we defer\n            // the actual removal to later\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            // NOTE: we skip nested keyed nodes from being removed since there is\n            //       still a chance they will be matched up later\n            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        } // END: while(curFromNodeChild) {}\n\n        // If we got this far then we did not find a candidate match for\n        // our \"to node\" and we exhausted all of the children \"from\"\n        // nodes. Therefore, we will just append the current \"to\" node\n        // to the end\n        if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n          // MORPH\n          if(!skipFrom){ addChild(fromEl, matchingFromEl); }\n          morphEl(matchingFromEl, curToNodeChild);\n        } else {\n          var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n          if (onBeforeNodeAddedResult !== false) {\n            if (onBeforeNodeAddedResult) {\n              curToNodeChild = onBeforeNodeAddedResult;\n            }\n\n            if (curToNodeChild.actualize) {\n              curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n            }\n            addChild(fromEl, curToNodeChild);\n            handleNodeAdded(curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n      }\n\n      cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n      var specialElHandler = specialElHandlers[fromEl.nodeName];\n      if (specialElHandler) {\n        specialElHandler(fromEl, toEl);\n      }\n    } // END: morphChildren(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n      // Handle the case where we are given two DOM nodes that are not\n      // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n      if (morphedNodeType === ELEMENT_NODE) {\n        if (toNodeType === ELEMENT_NODE) {\n          if (!compareNodeNames(fromNode, toNode)) {\n            onNodeDiscarded(fromNode);\n            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n          }\n        } else {\n          // Going from an element node to a text node\n          morphedNode = toNode;\n        }\n      } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n        if (toNodeType === morphedNodeType) {\n          if (morphedNode.nodeValue !== toNode.nodeValue) {\n            morphedNode.nodeValue = toNode.nodeValue;\n          }\n\n          return morphedNode;\n        } else {\n          // Text node to something else\n          morphedNode = toNode;\n        }\n      }\n    }\n\n    if (morphedNode === toNode) {\n      // The \"to node\" was not compatible with the \"from node\" so we had to\n      // toss out the \"from node\" and use the \"to node\"\n      onNodeDiscarded(fromNode);\n    } else {\n      if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n        return;\n      }\n\n      morphEl(morphedNode, toNode, childrenOnly);\n\n      // We now need to loop over any keyed nodes that might need to be\n      // removed. We only do the removal if we know that the keyed node\n      // never found a match. When a keyed node is matched up we remove\n      // it out of fromNodesLookup and we use fromNodesLookup to determine\n      // if a keyed node has been matched up or not\n      if (keyedRemovalList) {\n        for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n          var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n          if (elToRemove) {\n            removeNode(elToRemove, elToRemove.parentNode, false);\n          }\n        }\n      }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n      if (morphedNode.actualize) {\n        morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n      }\n      // If we had to swap out the from node with a new node because the old\n      // node was not compatible with the target node then we need to\n      // replace the old DOM node in the original DOM tree. This is only\n      // possible if the original DOM node was part of a DOM tree which\n      // we know is the case if it has a parent node.\n      fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n  };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","import { ComponentObject, StateObject, StateValueType } from \"../types/StateObjectTypes\";\r\nimport RuntimeManager from \"./RuntimeManager\";\r\nimport { EventObject } from \"../types/RuntimeInterfaces\";\r\nimport { utf8ToBase64 } from \"../utils/baseConverter\";\r\nimport morphdom from \"morphdom\";\r\n\r\nexport default class AppManager {\r\n   /**\r\n    * Navigates to a given URL using PHPSPA's custom navigation logic.\r\n    * Fetches the content via a custom HTTP method, updates the DOM, manages browser history,\r\n    * emits lifecycle events, and executes inline scripts.\r\n    *\r\n    * @param url - The URL or path to navigate to.\r\n    * @param state Determines whether to push or replace the browser history state.\r\n    *\r\n    * @fires AppManager#beforeload - Emitted before loading the new route.\r\n    * @fires AppManager#load - Emitted after attempting to load the new route, with success or error status.\r\n    */\r\n   public static navigate(url: URL|string, state: 'push' | 'replace' = \"push\") {\r\n      const newUrl = url instanceof URL ? url : new URL(url, location.toString());\r\n\r\n      // --- Emit beforeload event for loading indicators ---\r\n      RuntimeManager.emit(\"beforeload\", { route: newUrl.toString() });\r\n\r\n      // --- Fetch content from the server with PhpSPA headers ---\r\n      fetch(newUrl, {\r\n         headers: {\r\n            \"X-Requested-With\": \"PHPSPA_REQUEST\",\r\n            \"X-Phpspa-Target\": \"navigate\",\r\n         },\r\n         mode: \"same-origin\",\r\n         redirect: \"follow\",\r\n         keepalive: true,\r\n      })\r\n         .then((response) => {\r\n            response\r\n               .text()\r\n               .then((responseText) => {\r\n                  let responseData;\r\n\r\n                  // --- Try to parse JSON response, fallback to raw text ---\r\n                  if (responseText && responseText.trim().startsWith(\"{\")) {\r\n                     try {\r\n                        responseData = JSON.parse(responseText);\r\n                     } catch (parseError) {\r\n                        responseData = responseText;\r\n                     }\r\n                  } else {\r\n                     responseData = responseText || \"\"; // --- Handle empty responses ---\r\n                  }\r\n\r\n                  processResponse(responseData);\r\n               })\r\n               .catch((error) => handleError(error));\r\n         })\r\n         .catch((error) => handleError(error));\r\n\r\n      /**\r\n       * Handles errors that occur during navigation requests\r\n       * @param {Error} error - The error object from the failed request\r\n       */\r\n      function handleError(error: any) {\r\n         // --- Check if the error has a response body (HTTP 4xx/5xx errors) ---\r\n         if (error.response) {\r\n            error.response\r\n               .text()\r\n               .then((fallbackResponse: any) => {\r\n                  let errorData;\r\n\r\n                  try {\r\n                     // --- Attempt to parse error response as JSON ---\r\n                     errorData = fallbackResponse?.trim().startsWith(\"{\")\r\n                        ? JSON.parse(fallbackResponse)\r\n                        : fallbackResponse;\r\n                  } catch (parseError) {\r\n                     // --- If parsing fails, use raw text ---\r\n                     errorData = fallbackResponse;\r\n                  }\r\n\r\n                  processResponse(errorData || \"\");\r\n\r\n                  RuntimeManager.emit(\"load\", {\r\n                     route: newUrl.toString(),\r\n                     success: false,\r\n                     error: error.message || \"Server returned an error\",\r\n                     data: errorData,\r\n                  });\r\n               })\r\n               .catch(() => {\r\n                  processResponse(\"\");\r\n\r\n                  // --- Failed to read error response body ---\r\n                  RuntimeManager.emit(\"load\", {\r\n                     route: newUrl.toString(),\r\n                     success: false,\r\n                     error: error.message || \"Failed to read error response\",\r\n                  });\r\n               });\r\n         } else {\r\n            processResponse(\"\");\r\n\r\n            // --- Network error, same-origin issue, or other connection problems ---\r\n            RuntimeManager.emit(\"load\", {\r\n               route: newUrl.toString(),\r\n               success: false,\r\n               error: error.message || \"No connection to server\",\r\n            });\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Processes the server response and updates the DOM\r\n       */\r\n      function processResponse(responseData: ComponentObject|string) {\r\n         const component: ComponentObject = typeof responseData === 'string'\r\n            ? { content: responseData }\r\n            : responseData;\r\n\r\n         // --- Update document title if provided ---\r\n         if (component?.title && component.title.length > 0) {\r\n            document.title = component.title;\r\n         }\r\n\r\n         // --- Find target element for content replacement ---\r\n         const targetElement =\r\n            document.getElementById(component?.targetID) ??\r\n            document.getElementById(history.state?.targetID) ??\r\n            document.body;\r\n\r\n         if (component?.targetID) {\r\n            RuntimeManager.currentRoutes[component.targetID] = {\r\n               route: newUrl,\r\n               exact: component.exact ?? false,\r\n               defaultContent: RuntimeManager.currentRoutes[component.targetID]?.defaultContent ?? targetElement.innerHTML\r\n            }\r\n         }\r\n\r\n         const currentRoutes = RuntimeManager.currentRoutes;\r\n\r\n         for (const targetID in currentRoutes) {\r\n            if (!Object.hasOwn(currentRoutes, targetID)) continue;\r\n\r\n            const targetInfo = currentRoutes[targetID];\r\n\r\n            // --- If route is exact and the route target ID is not equal to the navigated route target ID ---\r\n            // --- Then the document URL has changed ---\r\n            // --- That is they are navigating away ---\r\n            // --- And any route with exact === true must go back to its default content ---\r\n            if (targetInfo.exact === true && targetID !== component?.targetID) {\r\n               let currentHTML = document.getElementById(targetID)\r\n               if (currentHTML) {\r\n                  try {\r\n                     morphdom(currentHTML, '<div>' + targetInfo.defaultContent + '</div>', {\r\n                        childrenOnly: true\r\n                     });\r\n                  } catch {\r\n                     currentHTML.innerHTML = targetInfo.defaultContent;\r\n                  }\r\n               }\r\n\r\n               delete currentRoutes[targetID];\r\n            }\r\n         }\r\n\r\n         // --- Update content ---\r\n         const updateDOM = () => {\r\n            try {\r\n               morphdom(targetElement, '<div>' + component.content + '</div>', {\r\n                  childrenOnly: true\r\n               });\r\n            } catch {\r\n               targetElement.innerHTML = component.content;\r\n            }\r\n         }\r\n\r\n\r\n         const stateData: StateObject = {\r\n            url: newUrl.toString(),\r\n            title: component?.title ?? document.title,\r\n            targetID: targetElement.id,\r\n            content: component.content,\r\n            exact: currentRoutes[component?.targetID]?.exact,\r\n            defaultContent: currentRoutes[component?.targetID]?.defaultContent,\r\n         }\r\n\r\n         // --- Include reload time if specified ---\r\n         if (component?.reloadTime) {\r\n            stateData.reloadTime = component.reloadTime;\r\n         }\r\n\r\n         const completedDOMUpdate = () => {\r\n\r\n            // --- Update browser history ---\r\n            if (state === \"push\") {\r\n               RuntimeManager.pushState(stateData, stateData.title, newUrl);\r\n            } else if (state === \"replace\") {\r\n               RuntimeManager.replaceState(stateData, stateData.title, newUrl);\r\n            }\r\n\r\n            // --- Handle URL fragments (hash navigation) ---\r\n            const hashElement = document.getElementById(newUrl.hash.substring(1));\r\n\r\n            if (hashElement) {\r\n               scroll({\r\n                  top: hashElement.offsetTop,\r\n                  left: hashElement.offsetLeft,\r\n               });\r\n            } else {\r\n               scroll(0, 0); // --- Scroll to top if no hash or element not found ---\r\n            }\r\n\r\n\r\n            // --- Clear old executed scripts cache ---\r\n            RuntimeManager.clearEffects();\r\n            RuntimeManager.clearExecutedScripts();\r\n\r\n            // --- Execute any inline scripts and styles in the new content ---\r\n            RuntimeManager.runAll();\r\n\r\n            // --- Emit successful load event ---\r\n            RuntimeManager.emit(\"load\", {\r\n               route: newUrl.toString(),\r\n               success: true,\r\n               error: false,\r\n            });\r\n\r\n            // --- Set up auto-reload if specified ---\r\n            if (component?.reloadTime) {\r\n               setTimeout(AppManager.reloadComponent, component.reloadTime);\r\n            }\r\n         }\r\n\r\n         if (document.startViewTransition) {\r\n            document.startViewTransition(updateDOM).finished.then(completedDOMUpdate).catch((reason) => {\r\n               RuntimeManager.emit('load', {\r\n                  route: newUrl.toString(),\r\n                  success: false,\r\n                  error: reason || 'Unknown error during view transition',\r\n               });\r\n            });\r\n         } else {\r\n            updateDOM();\r\n            completedDOMUpdate();\r\n         }\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Navigates back in the browser history.\r\n    * Uses the native browser history API.\r\n    */\r\n   public static back() {\r\n      history.back();\r\n   }\r\n\r\n   /**\r\n    * Navigates forward in the browser's session history.\r\n    * Uses the native browser history API.\r\n    */\r\n   public static forward() {\r\n      history.forward();\r\n   }\r\n\r\n   /**\r\n    * Reloads the current page by navigating to the current URL using the \"replace\" history mode.\r\n    * This does not add a new entry to the browser's history stack.\r\n    */\r\n   public static reload() {\r\n      AppManager.navigate(location.toString(), \"replace\");\r\n   }\r\n\r\n   /**\r\n    * Registers a callback function to be executed when the specified event is triggered.\r\n    *\r\n    * @param event - The name of the event to listen for.\r\n    * @param callback - The function to call when the event is triggered.\r\n    */\r\n   public static on(event: keyof EventObject, callback: () => void) {\r\n      if (!RuntimeManager.events[event]) {\r\n         RuntimeManager.events[event] = [];\r\n      }\r\n      RuntimeManager.events[event].push(callback);\r\n   }\r\n\r\n   /**\r\n    * Registers a side effect to be executed after component updates.\r\n    * Alias for RuntimeManager.registerEffect.\r\n    * \r\n    * @param callback - The effect callback\r\n    * @param dependencies - Array of state keys to listen for\r\n    */\r\n   public static useEffect(callback: () => Function|undefined, dependencies: string[]|null = null) {\r\n      RuntimeManager.registerEffect(callback, dependencies);\r\n   }\r\n\r\n   /**\r\n    * Updates the application state by sending a custom fetch request and updating the DOM accordingly.\r\n    * Preserves the current scroll position during the update.\r\n    *\r\n    * @param key - The key representing the state to update.\r\n    * @param value - The new value to set for the specified state key.\r\n    * @returns A promise that resolves when the state is updated successfully.\r\n    *\r\n    * @example\r\n    * AppManager.setState('user', { name: 'Alice' })\r\n    *   .then(() => console.log('State updated!'))\r\n    *   .catch(err => console.error('Failed to update state:', err));\r\n    */\r\n   public static setState(key: string, value: StateValueType): Promise<void> {\r\n      return new Promise(async (resolve, reject) => {\r\n         const currentRoutes = RuntimeManager.currentRoutes;\r\n         const statePayload = JSON.stringify({ state: { key, value } });\r\n         const promises = [];\r\n\r\n         for (const targetID in currentRoutes) {\r\n            if (!Object.hasOwn(currentRoutes, targetID)) continue;\r\n\r\n            const { route } = currentRoutes[targetID];\r\n\r\n            const prom = fetch(route, {\r\n               headers: {\r\n                  \"X-Requested-With\": \"PHPSPA_REQUEST\",\r\n                  Authorization: `Bearer ${utf8ToBase64(statePayload)}`,\r\n               },\r\n               mode: \"same-origin\",\r\n               redirect: \"follow\",\r\n               keepalive: true,\r\n            });\r\n            promises.push(prom);\r\n         }\r\n\r\n         const responses = await Promise.all(promises);\r\n\r\n         responses.forEach(async (response) => {\r\n            try {\r\n               const responseText = await response.text();\r\n               let responseData;\r\n\r\n               // --- Parse response as JSON if possible ---\r\n               if (responseText && responseText.trim().startsWith(\"{\")) {\r\n                  try {\r\n                     responseData = JSON.parse(responseText);\r\n                  } catch (parseError) {\r\n                     responseData = responseText;\r\n                  }\r\n               } else {\r\n                  responseData = responseText || \"\";\r\n               }\r\n\r\n               resolve();\r\n               updateContent(responseData);\r\n            } catch (error) {\r\n               reject(error);\r\n               handleStateError(error);\r\n            }\r\n         });\r\n\r\n\r\n         /**\r\n          * Handles errors during state update requests\r\n          */\r\n         function handleStateError(error: any) {\r\n            if (error?.response) {\r\n               error.response\r\n                  .text()\r\n                  .then((fallbackResponse: any) => {\r\n                     let errorData;\r\n\r\n                     try {\r\n                        errorData = fallbackResponse?.trim().startsWith(\"{\")\r\n                           ? JSON.parse(fallbackResponse)\r\n                           : fallbackResponse;\r\n                     } catch (parseError) {\r\n                        errorData = fallbackResponse;\r\n                     }\r\n\r\n                     updateContent(errorData || \"\");\r\n                  })\r\n                  .catch(() => {\r\n                     updateContent(\"\");\r\n                  });\r\n            } else {\r\n               updateContent(\"\");\r\n            }\r\n         }\r\n\r\n         /**\r\n          * Updates the DOM content and restores scroll position\r\n          * @param {string|Object} responseData - The response data to process\r\n          */\r\n         function updateContent(responseData: ComponentObject|string) {\r\n         const component: ComponentObject = typeof responseData === 'string'\r\n            ? { content: responseData }\r\n            : responseData;\r\n   \r\n            // --- Update title if provided ---\r\n            if (component?.title && String(component.title).length > 0) {\r\n               document.title = component.title;\r\n            }\r\n\r\n            // --- Find target element and update content ---\r\n            const targetElement =\r\n               document.getElementById(component?.targetID) ??\r\n               document.getElementById(history.state?.targetID) ??\r\n               document.body;\r\n\r\n            const updateDOM = () => {\r\n               try {\r\n                  morphdom(targetElement, '<div>' + component.content + '</div>', {\r\n                     childrenOnly: true\r\n                  });\r\n               } catch {\r\n                  targetElement.innerHTML = component.content;\r\n               }\r\n            };\r\n\r\n            const completedDOMUpdate = () => {\r\n               // --- Trigger effects for the changed key ---\r\n               RuntimeManager.triggerEffects(key, value);\r\n            };\r\n\r\n            updateDOM();\r\n            completedDOMUpdate();\r\n         }\r\n      });\r\n   }\r\n\r\n   /**\r\n    * Reloads the current component content while preserving scroll position.\r\n    * Useful for refreshing dynamic content without full page navigation.\r\n    */\r\n   static reloadComponent() {\r\n\r\n      // --- Fetch current page content ---\r\n      fetch(location.toString(), {\r\n         headers: {\r\n            \"X-Requested-With\": \"PHPSPA_REQUEST\",\r\n         },\r\n         mode: \"same-origin\",\r\n         redirect: \"follow\",\r\n         keepalive: true,\r\n      })\r\n         .then((response) => {\r\n            response\r\n               .text()\r\n               .then((responseText) => {\r\n                  let responseData;\r\n\r\n                  // --- Parse response ---\r\n                  if (responseText && responseText.trim().startsWith(\"{\")) {\r\n                     try {\r\n                        responseData = JSON.parse(responseText);\r\n                     } catch (parseError) {\r\n                        responseData = responseText;\r\n                     }\r\n                  } else {\r\n                     responseData = responseText || \"\";\r\n                  }\r\n\r\n                  updateComponentContent(responseData);\r\n               })\r\n               .catch((error) => {\r\n                  handleComponentError(error);\r\n               });\r\n         })\r\n         .catch((error) => {\r\n            handleComponentError(error);\r\n         });\r\n\r\n      /**\r\n       * Handles errors during component reload\r\n       */\r\n      function handleComponentError(error: any) {\r\n         if (error?.response) {\r\n            error.response\r\n               .text()\r\n               .then((fallbackResponse: string) => {\r\n                  let errorData;\r\n\r\n                  try {\r\n                     errorData = fallbackResponse?.trim().startsWith(\"{\")\r\n                        ? JSON.parse(fallbackResponse)\r\n                        : fallbackResponse;\r\n                  } catch (parseError) {\r\n                     errorData = fallbackResponse;\r\n                  }\r\n\r\n                  updateComponentContent(errorData || \"\");\r\n               })\r\n               .catch(() => {\r\n                  updateComponentContent(\"\");\r\n               });\r\n         } else {\r\n            updateComponentContent(\"\");\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Updates the component content and handles auto-reload\r\n       */\r\n      function updateComponentContent(responseData: ComponentObject|string) {\r\n         const component: ComponentObject = typeof responseData === 'string'\r\n            ? { content: responseData }\r\n            : responseData;\r\n\r\n         // --- Update title if provided ---\r\n         if (component?.title && String(component.title).length > 0) {\r\n            document.title = component.title;\r\n         }\r\n\r\n         // --- Find target and update content ---\r\n         const targetElement =\r\n            document.getElementById(component?.targetID) ??\r\n            document.getElementById(history.state?.targetID) ??\r\n            document.body;\r\n\r\n         const updateDOM = () => {\r\n            try {\r\n               morphdom(targetElement, '<div>' + component.content + '</div>', {\r\n                  childrenOnly: true\r\n               });\r\n            } catch {\r\n               targetElement.innerHTML = component.content;\r\n            }\r\n         };\r\n\r\n         const completedDOMUpdate = () => {\r\n            // --- Clear old executed scripts cache ---\r\n            RuntimeManager.clearEffects();\r\n            RuntimeManager.clearExecutedScripts();\r\n\r\n            // --- Execute any inline scripts and styles in the new content ---\r\n            RuntimeManager.runAll();\r\n\r\n            // --- Set up next auto-reload if specified ---\r\n            if (component?.reloadTime) {\r\n               setTimeout(AppManager.reloadComponent, component.reloadTime);\r\n            }\r\n         }\r\n\r\n         updateDOM();\r\n         completedDOMUpdate();\r\n      }\r\n   }\r\n\r\n   /**\r\n    * Makes an authenticated call to the server with a token and arguments.\r\n    * Used for server-side function calls from the client.\r\n    *\r\n    * @param token - The authentication token for the call\r\n    * @param args - Arguments to pass to the server function\r\n    * @returns The decoded response from the server\r\n    */\r\n   public static async __call(token: string, ...args: any[]): Promise<StateValueType> {\r\n      const callPayload = JSON.stringify({ __call: { token, args } });\r\n\r\n      try {\r\n         const response = await fetch(location.pathname, {\r\n            headers: {\r\n               \"X-Requested-With\": \"PHPSPA_REQUEST\",\r\n               Authorization: `Bearer ${utf8ToBase64(callPayload)}`,\r\n            },\r\n            mode: \"same-origin\",\r\n            redirect: \"follow\",\r\n            keepalive: true,\r\n         });\r\n\r\n         const responseText = await response.text();\r\n         let responseData;\r\n\r\n         // --- Parse and decode response ---\r\n         if (responseText && responseText.trim().startsWith(\"{\")) {\r\n            try {\r\n               responseData = JSON.parse(responseText);\r\n               responseData = responseData?.response\r\n                  ? JSON.parse(responseData.response)\r\n                  : responseData;\r\n            } catch (parseError) {\r\n               responseData = responseText;\r\n            }\r\n         } else {\r\n            responseData = responseText || \"\";\r\n         }\r\n\r\n         return responseData;\r\n      } catch (error: any) {\r\n         // --- Handle errors with response bodies ---\r\n         if (error?.response) {\r\n            try {\r\n               const fallbackResponse = await error.response.text();\r\n               let errorData;\r\n\r\n               try {\r\n                  errorData = fallbackResponse?.trim().startsWith(\"{\")\r\n                     ? JSON.parse(fallbackResponse)\r\n                     : fallbackResponse;\r\n\r\n                  errorData = errorData?.response\r\n                     ? JSON.parse(errorData.response)\r\n                     : errorData;\r\n               } catch (parseError) {\r\n                  errorData = fallbackResponse;\r\n               }\r\n\r\n               return errorData;\r\n            } catch {\r\n               return \"\";\r\n            }\r\n         } else {\r\n            // --- Network errors or other issues ---\r\n            return \"\";\r\n         }\r\n      }\r\n   }\r\n}","import AppManager from \"./core/AppManager\";\r\nimport RuntimeManager from \"./core/RuntimeManager\";\r\nimport { StateObject } from \"./types/StateObjectTypes\";\r\nimport { base64ToUtf8 } from \"./utils/baseConverter\";\r\nimport morphdom from \"morphdom\";\r\nimport phpspa from \"./types\";\r\n\r\ndeclare global {\r\n   export interface Window {\r\n      phpspa: typeof phpspa;\r\n      setState: typeof phpspa.setState;\r\n      useEffect: typeof phpspa.useEffect;\r\n      __call: typeof phpspa.__call;\r\n   }\r\n}\r\n\r\n/**\r\n * Initialize PhpSPA when DOM is ready\r\n * Sets up the initial browser history state with the current page content\r\n */\r\nwindow.addEventListener(\"DOMContentLoaded\", () => {\r\n   const targetElement = document.querySelector(\"[data-phpspa-target]\");\r\n   const targetElementInfo = document.querySelector(\"[phpspa-target-data]\");\r\n   const uri = location.toString();\r\n\r\n   RuntimeManager.emit('load', {\r\n      route: uri,\r\n      success: true,\r\n      error: false\r\n   });\r\n\r\n   if (targetElement) {\r\n      /**\r\n       *  Create initial state object with current page data\r\n       */\r\n      const initialState: StateObject = {\r\n         url: uri,\r\n         title: document.title,\r\n         targetID: targetElement.id,\r\n         content: targetElement.innerHTML,\r\n         root: true,\r\n      };\r\n\r\n      // --- Check if component has auto-reload functionality ---\r\n      if (targetElement.hasAttribute(\"phpspa-reload-time\")) {\r\n         initialState.reloadTime = Number(\r\n            targetElement.getAttribute(\"phpspa-reload-time\")\r\n         );\r\n      }\r\n\r\n      // --- Check if component has target info ---\r\n      if (targetElementInfo) {\r\n         const targetData = targetElementInfo.getAttribute(\"phpspa-target-data\");\r\n\r\n         // --- This is the json type coming from the server\r\n         type StateDataType = {\r\n            targetIDs: string[],\r\n            currentRoutes: string[],\r\n            defaultContent: string[],\r\n            exact: boolean[],\r\n         }\r\n\r\n         const targetDataInfo: StateDataType = JSON.parse(base64ToUtf8(targetData ?? ''));\r\n\r\n         targetDataInfo.targetIDs.forEach((targetID: string, index: number) => {\r\n            const exact = targetDataInfo.exact[index];\r\n            const defaultContent = targetDataInfo.defaultContent[index];\r\n\r\n            if (targetID === targetElement.id) {\r\n               initialState['exact'] = exact;\r\n               initialState['defaultContent'] = defaultContent;\r\n            }\r\n\r\n            RuntimeManager.currentRoutes[targetID] = {\r\n               route: new URL(targetDataInfo.currentRoutes[index], uri),\r\n               defaultContent,\r\n               exact\r\n            }\r\n         })\r\n      }\r\n\r\n      // --- Replace current history state with PhpSPA data ---\r\n      RuntimeManager.replaceState(\r\n         initialState,\r\n         document.title,\r\n         uri\r\n      );\r\n\r\n      // --- Set up auto-reload if specified ---\r\n      if (initialState.reloadTime) {\r\n         setTimeout(AppManager.reloadComponent, initialState.reloadTime);\r\n      }\r\n   }\r\n});\r\n\r\n\r\n/**\r\n * Handle browser back/forward button navigation\r\n * Restores page content when user navigates through browser history\r\n */\r\nwindow.addEventListener(\"popstate\", (event: PopStateEvent) => {\r\n   const navigationState: StateObject = event.state;\r\n\r\n   RuntimeManager.emit('beforeload', { route: location.toString() });\r\n\r\n   // --- Enable automatic scroll restoration ---\r\n   history.scrollRestoration = \"auto\";\r\n\r\n   // --- Check if we have valid PhpSPA state data ---\r\n   if (navigationState && navigationState.content) {\r\n      // --- Restore page title ---\r\n      document.title = navigationState.title ?? document.title;\r\n\r\n      // --- Find target container or fallback to body ---\r\n      const targetContainer =\r\n         document.getElementById(navigationState.targetID);\r\n\r\n      if (!targetContainer) {\r\n         location.reload();\r\n         return;\r\n      }\r\n\r\n      if (navigationState.targetID) {\r\n         RuntimeManager.currentRoutes[navigationState.targetID] = {\r\n            route: new URL(navigationState.url),\r\n            exact: navigationState.exact ?? false,\r\n            defaultContent: navigationState.defaultContent || ''\r\n         }\r\n      }\r\n\r\n      const currentRoutes = RuntimeManager.currentRoutes;\r\n\r\n      for (const targetID in currentRoutes) {\r\n         if (!Object.hasOwn(currentRoutes, targetID)) continue;\r\n\r\n         const targetInfo = currentRoutes[targetID];\r\n\r\n         // --- If route is exact and the route target ID is not equal to the navigated route target ID ---\r\n         // --- Then the document URL has changed ---\r\n         // --- That is they are navigating away ---\r\n         // --- And any route with exact === true must go back to its default content ---\r\n         if (targetInfo.exact === true && targetID !== navigationState.targetID) {\r\n            let currentHTML = document.getElementById(targetID)\r\n            if (currentHTML) {\r\n               try {\r\n                  morphdom(currentHTML, '<div>' + targetInfo.defaultContent + '</div>', {\r\n                     childrenOnly: true\r\n                  });\r\n               } catch {\r\n                  currentHTML.innerHTML = targetInfo.defaultContent;\r\n               }\r\n            }\r\n\r\n            delete currentRoutes[targetID];\r\n         }\r\n      }\r\n\r\n      // --- Decode and restore HTML content ---\r\n      const updateDOM = () => {\r\n         try {\r\n            morphdom(targetContainer, '<div>' + navigationState.content + '</div>', {\r\n               childrenOnly: true\r\n            });\r\n         } catch {\r\n            targetContainer.innerHTML = navigationState.content;\r\n         }\r\n      }\r\n\r\n      const completedDOMUpdate = () => {\r\n         // --- Clear old executed scripts cache ---\r\n         RuntimeManager.clearEffects();\r\n         RuntimeManager.clearExecutedScripts();\r\n\r\n         // --- Execute any inline scripts and styles in the restored content ---\r\n         RuntimeManager.runAll();\r\n\r\n         // --- Restart auto-reload timer if needed ---\r\n         if (navigationState?.reloadTime) {\r\n            setTimeout(AppManager.reloadComponent, navigationState.reloadTime);\r\n         }\r\n\r\n         RuntimeManager.emit('load', {\r\n            route: navigationState.url,\r\n            success: true,\r\n            error: false\r\n         });\r\n      }\r\n\r\n      if (document.startViewTransition) {\r\n         document.startViewTransition(updateDOM).finished.then(completedDOMUpdate).catch((reason) => {\r\n            RuntimeManager.emit('load', {\r\n               route: location.href,\r\n               success: false,\r\n               error: reason || 'Unknown error during view transition',\r\n            });\r\n         });\r\n      } else {\r\n         updateDOM();\r\n         completedDOMUpdate();\r\n      }\r\n\r\n   } else {\r\n      // --- No valid state found - reload current URL to refresh ---\r\n      location.reload();\r\n   }\r\n});\r\n\r\n\r\nif (typeof window !== \"undefined\") {\r\n   if (typeof window.setState !== \"function\") {\r\n      window.setState = AppManager.setState;\r\n   }\r\n\r\n   if (typeof window.__call !== \"function\") {\r\n      window.__call = AppManager.__call;\r\n   }\r\n\r\n   if (typeof window.useEffect !== \"function\") {\r\n      window.useEffect = AppManager.useEffect;\r\n   }\r\n}\r\n\r\n\r\nexport default AppManager;\r\n"],"names":["utf8ToBase64","str","btoa","e","utf8Bytes","TextEncoder","encode","binaryString","Array","from","byte","String","fromCharCode","join","fallbackError","split","map","c","charCodeAt","RuntimeManager","static","Set","beforeload","load","registerEffect","callback","dependencies","cleanup","effect","effects","add","triggerEffects","key","value","forEach","includes","clearEffects","clear","runAll","targetID","currentRoutes","element","document","getElementById","this","runInlineScripts","runPhpSpaScripts","runInlineStyles","container","scripts","querySelectorAll","nonce","documentElement","getAttribute","script","contentHash","textContent","trim","executedScripts","has","newScript","createElement","undefined","attribute","attributes","setAttribute","name","isAsync","hasAttribute","head","appendChild","remove","async","scriptUrl","scriptType","ScriptsCachedContent","type","response","fetch","headers","ok","scriptContent","text","console","error","statusText","clearExecutedScripts","styles","style","executedStyles","newStyle","emit","eventName","payload","callbacks","events","pushState","data","unused","url","history","warn","Error","message","replaceState","range","doc","HAS_TEMPLATE_SUPPORT","HAS_RANGE_SUPPORT","createRange","toElement","template","innerHTML","content","childNodes","createFragmentFromTemplate","selectNode","body","createContextualFragment","createFragmentFromRange","fragment","createFragmentFromWrap","compareNodeNames","fromEl","toEl","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","toUpperCase","syncBooleanAttrProp","removeAttribute","specialElHandlers","OPTION","parentNode","parentName","selected","selectedIndex","INPUT","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","nextSibling","noop","defaultGetNodeKey","node","id","morphdom","morphAttrs","fromNode","toNode","options","toNodeHtml","nodeType","firstElementChild","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","skipFromChildren","addChild","parent","child","childrenOnly","fromNodesLookup","Object","create","keyedRemovalList","addKeyedRemoval","push","walkDiscardedChildNodes","skipKeyedNodes","removeNode","removeChild","indexTree","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","beforeUpdateResult","HTMLElement","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","skipFrom","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","namespaceURI","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","length","elToRemove","morphdomFactory","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","AppManager","navigate","state","newUrl","URL","location","toString","handleError","then","fallbackResponse","errorData","startsWith","JSON","parse","parseError","processResponse","route","success","catch","responseData","component","title","targetElement","exact","defaultContent","hasOwn","targetInfo","currentHTML","updateDOM","stateData","reloadTime","completedDOMUpdate","hashElement","hash","substring","scroll","top","offsetTop","left","offsetLeft","setTimeout","reloadComponent","startViewTransition","finished","reason","mode","redirect","keepalive","responseText","back","forward","reload","on","event","useEffect","setState","Promise","resolve","reject","statePayload","stringify","promises","prom","Authorization","updateContent","all","handleStateError","handleComponentError","updateComponentContent","__call","token","args","callPayload","pathname","window","addEventListener","querySelector","targetElementInfo","uri","initialState","root","Number","targetData","targetDataInfo","atob","bytes","Uint8Array","TextDecoder","decode","base64ToUtf8","targetIDs","index","navigationState","scrollRestoration","targetContainer","href"],"mappings":"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","x_google_ignoreList":[2]}